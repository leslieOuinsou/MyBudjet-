import User from '../models/user.js';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { createWelcomeNotification } from '../utils/notificationGenerator.js';
import { initializeDefaultData, addMissingCategories, addMissingWallets } from '../utils/defaultData.js';

export const register = async (req, res) => {
  const { name, email, password } = req.body;
  
  // Validation du mot de passe (minimum 12 caract√®res)
  if (!password || password.length < 12) {
    return res.status(400).json({ message: 'Le mot de passe doit contenir au moins 12 caract√®res' });
  }
  
  const existing = await User.findOne({ email });
  if (existing) return res.status(400).json({ message: 'Email already in use' });
  const hashedPassword = await bcrypt.hash(password, 10);
  const user = new User({ name, email, password: hashedPassword });
  await user.save();
  
  // Initialiser les donn√©es par d√©faut (cat√©gories et portefeuilles)
  await initializeDefaultData(user._id);
  
  // Cr√©er une notification de bienvenue
  await createWelcomeNotification(user._id, user.name);
  
  res.status(201).json({ message: 'User registered with default data initialized' });
};

export const login = async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });
  if (!user) return res.status(400).json({ message: 'Invalid credentials' });
  
  if (user.blocked) {
    return res.status(403).json({ message: 'Account is blocked. Contact support.' });
  }
  
  if (!user.password) {
    return res.status(400).json({ message: 'Please use social login or reset your password' });
  }
  
  const valid = await bcrypt.compare(password, user.password);
  if (!valid) return res.status(400).json({ message: 'Invalid credentials' });
  
  // Update last login
  user.lastLogin = new Date();
  await user.save();
  
  const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '7d' });
  res.json({ token, user: { id: user._id, name: user.name, email: user.email, role: user.role } });
};

export const googleCallback = async (req, res) => {
  try {
    // User is attached to req.user by passport
    if (!req.user) {
      console.error('‚ùå No user in Google callback');
      return res.redirect(`${process.env.FRONTEND_URL}/login?error=auth_failed`);
    }

    if (req.user.blocked) {
      console.error('‚ùå User blocked:', req.user.email);
      return res.redirect(`${process.env.FRONTEND_URL}/login?error=account_blocked`);
    }
    
    // Update last login
    req.user.lastLogin = new Date();
    await req.user.save();
    
    const token = jwt.sign({ id: req.user._id }, process.env.JWT_SECRET, { expiresIn: '7d' });
    
    console.log('‚úÖ Google login successful for:', req.user.email);
    
    // Redirect to frontend with token
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
    res.redirect(`${frontendUrl}/auth/callback?token=${token}&user=${encodeURIComponent(JSON.stringify({
      id: req.user._id,
      name: req.user.name,
      email: req.user.email,
      role: req.user.role
    }))}`);
  } catch (error) {
    console.error('‚ùå Error in Google callback:', error);
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
    res.redirect(`${frontendUrl}/login?error=server_error`);
  }
};

// Fonction pour ajouter les donn√©es manquantes aux utilisateurs existants
export const addMissingDefaultData = async (req, res) => {
  try {
    const userId = req.user._id;
    
    // Ajouter les cat√©gories manquantes
    const categoriesResult = await addMissingCategories(userId);
    
    // Ajouter les portefeuilles manquants
    const walletsResult = await addMissingWallets(userId);
    
    res.json({
      success: true,
      message: 'Donn√©es par d√©faut ajout√©es',
      details: {
        categories: categoriesResult,
        wallets: walletsResult
      }
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'ajout des donn√©es par d√©faut:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erreur lors de l\'ajout des donn√©es par d√©faut',
      error: error.message 
    });
  }
};

// Inscription admin publique (avec code d'activation)
export const registerAdmin = async (req, res) => {
  try {
    const { name, email, password, adminCode } = req.body;
    
    console.log('üîê Inscription admin publique:', { email, name });
    
    // V√©rifier le code d'activation admin
    const ADMIN_CODE = process.env.ADMIN_CREATION_CODE || 'MYBUDGET-ADMIN-2025';
    
    if (adminCode !== ADMIN_CODE) {
      console.log('‚ùå Code admin invalide');
      return res.status(403).json({ 
        message: 'Code d\'activation admin invalide. Contactez le super-administrateur.' 
      });
    }
    
    // Validation du mot de passe (minimum 12 caract√®res pour admin)
    if (!password || password.length < 12) {
      return res.status(400).json({ 
        message: 'Le mot de passe admin doit contenir au moins 12 caract√®res' 
      });
    }
    
    // V√©rifier si l'email existe d√©j√†
    const existing = await User.findOne({ email: email.toLowerCase() });
    if (existing) {
      return res.status(400).json({ message: 'Cet email est d√©j√† utilis√©' });
    }
    
    // Hasher le mot de passe
    const hashedPassword = await bcrypt.hash(password, 12);
    
    // Cr√©er l'utilisateur avec le r√¥le admin
    const newAdmin = new User({
      name,
      email: email.toLowerCase(),
      password: hashedPassword,
      role: 'admin',
      emailVerified: true // Admin v√©rifi√© par d√©faut
    });
    
    await newAdmin.save();
    console.log('‚úÖ Admin cr√©√© via inscription publique:', newAdmin._id);
    
    // Initialiser les donn√©es par d√©faut
    await initializeDefaultData(newAdmin._id);
    
    // Cr√©er notification de bienvenue
    await createWelcomeNotification(newAdmin._id, newAdmin.name);
    
    res.status(201).json({
      success: true,
      message: 'Compte administrateur cr√©√© avec succ√®s. Vous pouvez maintenant vous connecter.',
      user: {
        id: newAdmin._id,
        name: newAdmin.name,
        email: newAdmin.email,
        role: newAdmin.role
      }
    });
    
  } catch (error) {
    console.error('‚ùå Erreur inscription admin:', error);
    res.status(500).json({ 
      message: 'Erreur lors de la cr√©ation du compte administrateur',
      error: error.message 
    });
  }
};
